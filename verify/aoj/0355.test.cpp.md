---
data:
  _extendedDependsOn:
  - icon: ':heavy_check_mark:'
    path: data-structure/lazy-segtree.cpp
    title: data-structure/lazy-segtree.cpp
  - icon: ':heavy_check_mark:'
    path: data-structure/segtree.cpp
    title: data-structure/segtree.cpp
  - icon: ':heavy_check_mark:'
    path: string/hash-monoid.cpp
    title: string/hash-monoid.cpp
  - icon: ':heavy_check_mark:'
    path: string/rolling-hash.cpp
    title: string/rolling-hash.cpp
  - icon: ':heavy_check_mark:'
    path: template.cpp
    title: template.cpp
  - icon: ':heavy_check_mark:'
    path: util/fast-io.cpp
    title: util/fast-io.cpp
  - icon: ':heavy_check_mark:'
    path: util/function-objects.cpp
    title: util/function-objects.cpp
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _pathExtension: cpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    '*NOT_SPECIAL_COMMENTS*': ''
    PROBLEM: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0355
    links:
    - http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0355
  bundledCode: "#line 1 \"verify/aoj/0355.test.cpp\"\n#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0355\"\
    \n\n#line 2 \"template.cpp\"\n\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n\
    #pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"avx\")\n#endif\n\
    #include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n\
    #include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n\
    #include <queue>\n#include <set>\n#include <stack>\nusing namespace std;\nusing\
    \ ll = long long;\nusing ull = unsigned long long;\nusing VI = vector<int>;\n\
    using VVI = vector<vector<int>>;\nusing VLL = vector<ll>;\nusing VVLL = vector<vector<ll>>;\n\
    using VB = vector<bool>;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\n\
    constexpr int INF = 1000000007;\nconstexpr ll INF_LL = 1'000'000'000'000'000'007;\n\
    #define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define newl\
    \ '\\n'\n\n// loops rep(until) / rep(var, until) / rep(var, from, until) / repr\
    \ (reversed order)\n#define OVERLOAD3(_1, _2, _3, name, ...) name\n#define rep(...)\
    \ OVERLOAD3(__VA_ARGS__, REPEAT_FROM_UNTIL, REPEAT_UNTIL, REPEAT)(__VA_ARGS__)\n\
    #define REPEAT(times) REPEAT_CNT(_repeat, __COUNTER__, times)\n#define REPEAT_CNT(_repeat,\
    \ cnt, times) REPEAT_CNT_CAT(_repeat, cnt, times)\n#define REPEAT_CNT_CAT(_repeat,\
    \ cnt, times) REPEAT_FROM_UNTIL(_repeat ## cnt, 0, times)\n#define REPEAT_UNTIL(name,\
    \ times) REPEAT_FROM_UNTIL(name, 0, times)\n#define REPEAT_FROM_UNTIL(name, from,\
    \ until) for (int name = from, name ## __until = (until); name < name ## __until;\
    \ name++)\n#define repr(...) OVERLOAD3(__VA_ARGS__, REPR_FROM_UNTIL, REPR_UNTIL,\
    \ REPEAT)(__VA_ARGS__)\n#define REPR_UNTIL(name, times) REPR_FROM_UNTIL(name,\
    \ 0, times)\n#define REPR_FROM_UNTIL(name, from, until) for (int name = (until)-1,\
    \ name ## __from = (from); name >= name ## __from; name--)\n\ntemplate <typename\
    \ T, typename U>\nbool chmin(T& var, U x) { if (var > x) { var = x; return true;\
    \ } else return false; }\ntemplate <typename T, typename U>\nbool chmax(T& var,\
    \ U x) { if (var < x) { var = x; return true; } else return false; }\nll power(ll\
    \ e, ll t, ll mod = INF_LL) {\n  ll res = 1; for (; t; t >>= 1, (e *= e) %= mod)\
    \ if (t & 1) (res *= e) %= mod; return res;\n}\nll choose(ll n, int r) {\n  chmin(r,\
    \ n-r); if (r < 0) return 0; ll res = 1; rep(i, r) res *= n-i, res /= i+1; return\
    \ res;\n}\ntemplate <typename T, typename U> T divceil(T m, U d) { return (m +\
    \ d - 1) / d; }\ntemplate <typename T> vector<T> make_v(size_t a, T b) { return\
    \ vector<T>(a, b); }\ntemplate <typename... Ts> auto make_v(size_t a, Ts... ts)\
    \ {\n  return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\n// debugging\
    \ stuff\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wmisleading-indentation\"\
    \n#define repi(it, ds) for (auto it = ds.begin(); it != ds.end(); it++)\nclass\
    \ DebugPrint { public: template <typename T> DebugPrint& operator <<(const T&\
    \ v) {\n#ifdef LOCAL\n    cerr << v;\n#endif\nreturn *this; } } debugos; template\
    \ <typename T> DebugPrint& operator<<(DebugPrint& os, const\nvector<T>& vec) {\
    \ os << \"{\"; for (int i = 0; i < vec.size(); i++) os << vec[i] << (i + 1 ==\n\
    vec.size() ? \"\" : \", \"); os << \"}\"; return os; } template <typename T, typename\
    \ U> DebugPrint&\noperator<<(DebugPrint& os, const map<T, U>& map_var) { os <<\
    \ \"{\"; repi(itr, map_var) { os << *\nitr; itr++; if (itr != map_var.end()) os\
    \ << \", \"; itr--; } os << \"}\"; return os; } template <\ntypename T> DebugPrint&\
    \ operator<<(DebugPrint& os, const set<T>& set_var) { os << \"{\"; repi(\nitr,\
    \ set_var) { os << *itr; itr++; if (itr != set_var.end()) os << \", \"; itr--;\
    \ } os << \"}\";\nreturn os; } template <typename T, typename U> DebugPrint& operator<<(DebugPrint&\
    \ os, const\npair<T, U>& p) { os << \"(\" << p.first << \", \" << p.second <<\
    \ \")\"; return os; } void dump_func(\n) { debugos << newl; } template <class\
    \ Head, class... Tail> void dump_func(Head &&head, Tail\n&&... tail) { debugos\
    \ << head; if (sizeof...(Tail) > 0) { debugos << \", \"; } dump_func(forward\n\
    <Tail>(tail)...); }\n#ifdef LOCAL\n#define dump(...) debugos << \"  \" << string(#__VA_ARGS__)\
    \ << \": \" << \"[\" << to_string(__LINE__) \\\n<< \":\" << __FUNCTION__ << \"\
    ]\" << newl << \"    \", dump_func(__VA_ARGS__)\n#else\n#define dump(...) ({})\n\
    #endif\n#pragma GCC diagnostic pop\n\n\n#line 2 \"string/rolling-hash.cpp\"\n\n\
    #include <random>\n#line 5 \"string/rolling-hash.cpp\"\n\nnamespace rolling_hash\
    \ {\n\nconstexpr ull mask30 = (1ULL << 30) - 1;\nconstexpr ull mask31 = (1ULL\
    \ << 31) - 1;\nconstexpr ull MOD = (1ULL << 61) - 1;\nrandom_device rd;\nint base\
    \ = uniform_int_distribution<int>(0)(rd);\nvector<ull> pows{1};\nvector<ull> sum_pows{1};\n\
    \null mod(ull val) {\n  val = (val & MOD) + (val >> 61);\n  return val >= MOD\
    \ ? val - MOD : val;\n}\n\null mul(ull l, ull r) {\n  ull lu = l >> 31, ld = l\
    \ & mask31;\n  ull ru = r >> 31, rd = r & mask31;\n  ull middle = ld * ru + lu\
    \ * rd;\n  return ((lu * ru) << 1) + ld * rd + ((middle & mask30) << 31) +\n \
    \        (middle >> 30);\n}\n\null mul(ull l, int r) {\n  ull lu = l >> 31, ld\
    \ = l & mask31;\n  ull middle = lu * r;\n  return ld * r + ((middle & mask30)\
    \ << 31) + (middle >> 30);\n}\n\nvoid prepare_pows(size_t sz) {\n  rep(i, pows.size()\
    \ - 1, sz - 1) pows.push_back(mod(mul(pows[i], base)));\n}\n\nvoid prepare_sum_pows(size_t\
    \ sz) {\n  prepare_pows(sz);\n  rep(i, sum_pows.size() - 1, sz - 1) {\n    sum_pows.push_back(mod(sum_pows[i]\
    \ + pows[i + 1]));\n  }\n}\n\null calc_hash(char c, int _length) {\n  prepare_sum_pows(_length);\n\
    \  return mod(mul(sum_pows[_length - 1], c));\n}\n\ntemplate <typename Iter>\n\
    ull calc_hash(Iter first, Iter last) {\n  ull res = 0;\n  while (first != last)\
    \ res = mod(mul(res, base) + *first++);\n  return res;\n}\n\n// monoid\nstruct\
    \ Hash {\n  ull value;\n  int length;\n\n  Hash() : value(0), length(0) {}  //\
    \ unit\n  Hash(ull _value, int _length) : value(_value), length(_length) {}\n\
    \  Hash(char c, int _length = 1)\n      : value(calc_hash(c, _length)), length(_length)\
    \ {}\n  template <typename Iter>\n  Hash(Iter first, Iter last): value(calc_hash(first,\
    \ last)), length(distance(first, last)) {}\n\n public:\n  operator ull() const\
    \ { return value; }\n  bool operator==(const Hash& rhs) const {\n    return value\
    \ == rhs.value && length == rhs.length;\n  }\n  bool operator!=(const Hash& rhs)\
    \ const {\n    return value != rhs.value && length != rhs.length;\n  }\n  bool\
    \ operator<(const Hash& rhs) const {\n    return make_pair(length, value) < make_pair(rhs.length,\
    \ rhs.value);\n  }\n};\n\nclass Calculator {\n private:\n  vector<ull> hash;\n\
    \n public:\n  template <typename Iter>\n  Calculator(Iter first, Iter last) :\
    \ hash(last - first + 1) {\n    prepare_pows(last - first + 1);\n    rep(i, last\
    \ - first) hash[i + 1] = mod(mul(hash[i], base) + first[i]);\n    // assert(hash[i+1]\
    \ < (1ULL << 62));\n  }\n\n public:\n  ull operator()(int l, int r) const {\n\
    \    static constexpr ull large = MOD * ((1 << 2) - 1);\n    return mod(hash[r]\
    \ + large - mul(hash[l], pows[r - l]));\n  }\n  Hash get_hash(int l, int r) const\
    \ {\n    return Hash(operator()(l, r), r - l);\n  }\n};\n\n}  // namespace rolling_hash\n\
    #line 2 \"data-structure/lazy-segtree.cpp\"\n\n#line 2 \"util/function-objects.cpp\"\
    \n\n#line 4 \"util/function-objects.cpp\"\n\nstruct minT {\n  template <typename\
    \ T>\n  T operator()(T a, T b) const {\n    return min(a, b);\n  }\n};\n\nstruct\
    \ maxT {\n  template <typename T>\n  T operator()(T a, T b) const {\n    return\
    \ max(a, b);\n  }\n};\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored\
    \ \"-Wunused-parameter\"\nstruct assignT {\n  template <typename T>\n  T operator()(T\
    \ a, T b, int k = 0) const { return b; }\n};\n#pragma GCC diagnostic pop\n\nstruct\
    \ plusT {\n  template <typename T>\n  T operator()(T a, T b, int k = 1) const\
    \ { return a + b * k; }\n};\n#line 5 \"data-structure/lazy-segtree.cpp\"\n\n#pragma\
    \ GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wshadow\"\ntemplate <typename\
    \ T, typename Actor, typename Combine, typename ACombine,\n          typename\
    \ Action>\nstruct LazySegmentTree {\n private:\n  const size_t n, h;\n  const\
    \ T unit;\n  const Actor aunit;\n  const Combine combine;\n  const ACombine acombine;\n\
    \  const Action upd;\n  vector<T> data;\n  vector<Actor> lazy;\n\n public:\n \
    \ LazySegmentTree(size_t n = 0, T unit = {}, Actor aunit = {},\n             \
    \     Combine combine = {}, ACombine acombine = {}, Action upd = {})\n      :\
    \ n(n),\n        h(32 - __builtin_clz(n)),\n        unit(unit),\n        aunit(aunit),\n\
    \        combine(combine),\n        acombine(acombine),\n        upd(upd),\n \
    \       data(n << 1, unit),\n        lazy(n, aunit) {\n    build(0, n);\n  }\n\
    \n  template <\n      typename Iter,\n      enable_if_t<is_same<typename Iter::value_type,\
    \ T>::value>* = nullptr>\n  LazySegmentTree(Iter first, Iter last, size_t n, T\
    \ unit = {},\n                  Actor aunit = {}, Combine combine = {},\n    \
    \              ACombine acombine = {}, Action upd = {})\n      : n(n),\n     \
    \   h(32 - __builtin_clz(n)),\n        unit(unit),\n        aunit(aunit),\n  \
    \      combine(combine),\n        acombine(acombine),\n        upd(upd),\n   \
    \     data(n << 1, unit),\n        lazy(n, aunit) {\n    copy(first, last, data.begin()\
    \ + n);\n    build(0, n);\n  }\n\n  template <\n      typename Iter,\n      enable_if_t<!is_same<typename\
    \ Iter::value_type, T>::value>* = nullptr>\n  [[deprecated]] LazySegmentTree(Iter\
    \ first, Iter last, size_t n, T unit = {},\n                                 Actor\
    \ aunit = {}, Combine combine = {},\n                                 ACombine\
    \ acombine = {}, Action upd = {})\n      : n(n),\n        h(32 - __builtin_clz(n)),\n\
    \        unit(unit),\n        aunit(aunit),\n        combine(combine),\n     \
    \   acombine(acombine),\n        upd(upd),\n        data(n << 1, unit),\n    \
    \    lazy(n, aunit) {\n    copy(first, last, data.begin() + n);\n    build(0,\
    \ n);\n  }\n\n  template <typename Iter>\n  LazySegmentTree(Iter first, Iter last,\
    \ T unit = {}, Actor aunit = {},\n                  Combine combine = {}, ACombine\
    \ acombine = {}, Action upd = {})\n      : LazySegmentTree(first, last, distance(first,\
    \ last), unit, aunit,\n                        combine, acombine, upd) {}\n\n\
    \ private:\n  void apply(int p, Actor e, int sz) {\n    if (e == aunit) return;\n\
    \    data[p] = upd(data[p], e, sz);\n    if (p < n) {\n      if (lazy[p] == aunit)\n\
    \        lazy[p] = e;\n      else\n        lazy[p] = acombine(lazy[p], e);\n \
    \   }\n  }\n\n  void pushdown(int p, int sz) {\n    if (p >= n or lazy[p] == aunit)\
    \ return;\n    apply(p << 1, lazy[p], sz >> 1);\n    apply(p << 1 | 1, lazy[p],\
    \ sz >> 1);\n    lazy[p] = aunit;\n  }\n\n  void pushup(int p, int sz) {\n   \
    \ if (p >= n) return;\n    data[p] = combine(data[p << 1], data[p << 1 | 1]);\n\
    \    if (lazy[p] != aunit) data[p] = upd(data[p], lazy[p], sz);\n  }\n\n  void\
    \ flush(int l, int r) {\n    int s = h, k = 1 << h;\n    for (l += n, r += n -\
    \ 1; s > 0; s--, k >>= 1)\n      for (int p = l >> s; p <= r >> s; p++) pushdown(p,\
    \ k);\n  }\n\n  void build(int l, int r) {\n    int sz = 2;\n    for (l += n,\
    \ r += n - 1; l > 1; sz <<= 1) {\n      l >>= 1, r >>= 1;\n      for (int p =\
    \ l; p <= r; p++) pushup(p, sz);\n    }\n  }\n\n public:\n  void modify(int l,\
    \ int r, Actor e) {\n    if (e == aunit) return;\n    flush(l, l + 1);\n    flush(r\
    \ - 1, r);\n    int l0 = l, r0 = r, k = 1;\n    for (l += n, r += n; l < r; l\
    \ >>= 1, r >>= 1, k <<= 1) {\n      if (l & 1) apply(l++, e, k);\n      if (r\
    \ & 1) apply(--r, e, k);\n    }\n    build(l0, l0 + 1);\n    build(r0 - 1, r0);\n\
    \  }\n\n  T fold(int l, int r) {\n    flush(l, l + 1);\n    flush(r - 1, r);\n\
    \    T resl = unit, resr = unit;\n    for (l += n, r += n; l < r; l >>= 1, r >>=\
    \ 1) {\n      if (l & 1) resl = combine(resl, data[l++]);\n      if (r & 1) resr\
    \ = combine(data[--r], resr);\n    }\n    return combine(resl, resr);\n  }\n};\n\
    #pragma GCC diagnostic pop\n#line 2 \"string/hash-monoid.cpp\"\n\n#line 2 \"data-structure/segtree.cpp\"\
    \n\n#line 5 \"data-structure/segtree.cpp\"\n\n#pragma GCC diagnostic push\n#pragma\
    \ GCC diagnostic ignored \"-Wshadow\"\ntemplate <typename T, typename Combine,\
    \ typename Action>\nclass SegmentTree {\n private:\n  const size_t n;\n  const\
    \ T unit;\n  const Combine combine;\n  const Action action;\n  vector<T> data;\n\
    \n public:\n  SegmentTree(size_t n = 0, T unit = {}, Combine combine = {},\n \
    \             Action action = {})\n      : n(n), unit(unit), combine(combine),\
    \ action(action), data(n << 1, unit) {\n    build();\n  }\n\n  template <\n  \
    \    typename Iter,\n      enable_if_t<is_same<typename Iter::value_type, T>::value>*\
    \ = nullptr>\n  SegmentTree(Iter first, Iter last, size_t n, T unit = {},\n  \
    \            Combine combine = {}, Action action = {})\n      : n(n), unit(unit),\
    \ combine(combine), action(action), data(n << 1) {\n    copy(first, last, data.begin()\
    \ + n);\n    build();\n  }\n\n  template <\n      typename Iter,\n      enable_if_t<!is_same<typename\
    \ Iter::value_type, T>::value>* = nullptr>\n  [[deprecated]] SegmentTree(Iter\
    \ first, Iter last, size_t n, T unit = {},\n                             Combine\
    \ combine = {}, Action action = {})\n      : n(n), unit(unit), combine(combine),\
    \ action(action), data(n << 1) {\n    copy(first, last, data.begin() + n);\n \
    \   build();\n  }\n\n  template <typename Iter>\n  SegmentTree(Iter first, Iter\
    \ last, T unit = {}, Combine combine = {},\n              Action action = {})\n\
    \      : SegmentTree(first, last, distance(first, last), unit, combine, action)\
    \ {\n  }\n\n private:\n  void build() { repr(i, n) data[i] = combine(data[i <<\
    \ 1], data[i << 1 | 1]); }\n\n public:\n  void modify(int l, T v) {\n    l +=\
    \ n;\n    data[l] = action(data[l], v);\n    for (; l > 1; l >>= 1) data[l >>\
    \ 1] = combine(data[l & (~1)], data[l | 1]);\n  }\n\n  T fold(int l, int r) const\
    \ {\n    if (l == r) return unit;\n    if (l + 1 == r) return data[l + n];\n \
    \   T resl = data[l += n], resr = data[(r += n) - 1];\n    for (l++, r--; l <\
    \ r; l >>= 1, r >>= 1) {\n      if (l & 1) resl = combine(resl, data[l++]);\n\
    \      if (r & 1) resr = combine(data[--r], resr);\n    }\n    return combine(resl,\
    \ resr);\n  }\n  // min r s.t. fold(l, r) >= v -- or n+1 if failed\n  template\
    \ <typename Compare = less<T>>\n  int lower_bound(T v, int l = 0, Compare comp\
    \ = {}) {\n    if (not comp(unit, v)) return l;\n    int r = n;\n    VI rootL,\
    \ rootR;\n    for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if (l & 1)\
    \ rootL.push_back(l++);\n      if (r & 1) rootR.push_back(--r);\n    }\n    VI\
    \ roots = move(rootL); roots.insert(roots.end(), rall(rootR));\n    T accL = unit;\n\
    \    for (int root : roots) {\n      T tmpL = combine(accL, data[root]);\n   \
    \   if (comp(tmpL, v)) {\n        accL = tmpL;\n        continue;\n      }\n \
    \     while (root < n) {\n        tmpL = combine(accL, data[root << 1]);\n   \
    \     if (comp(tmpL, v)) accL = tmpL, root = root << 1 | 1;\n        else root\
    \ = root << 1;\n      }\n      return root - n + 1;\n    }\n    return n + 1;\n\
    \  }\n};\n#pragma GCC diagnostic pop\n#line 6 \"string/hash-monoid.cpp\"\n\nnamespace\
    \ hash_monoid {\n\nusing namespace rolling_hash;\n\nstruct mergeT {\n  Hash operator()(const\
    \ Hash& lhs, const Hash& rhs) const {\n    prepare_pows(rhs.length + 1);\n   \
    \ return Hash(mod(mul(lhs.value, pows[rhs.length]) + rhs.value),\n           \
    \     lhs.length + rhs.length);\n  }\n};\n\n#pragma GCC diagnostic push\n#pragma\
    \ GCC diagnostic ignored \"-Wunused-parameter\"\nstruct updT {\n  Hash operator()(const\
    \ Hash& lhs, char c, int k = 1) const {\n    return Hash(c, k);\n  }\n};\n#pragma\
    \ GCC diagnostic pop\n\n}  // namespace hash_monoid\n\nusing HashSegTree =\n \
    \   SegmentTree<rolling_hash::Hash, hash_monoid::mergeT, hash_monoid::updT>;\n\
    using LazyHashSegTree =\n    LazySegmentTree<rolling_hash::Hash, char, hash_monoid::mergeT,\
    \ assignT,\n                    hash_monoid::updT>;\n#line 1 \"util/fast-io.cpp\"\
    \n\n// IO\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wmisleading-indentation\"\
    \nclass MyScanner { public: int offset = 0; char nc(){ return getchar(); }\ntemplate\
    \ <typename T> void input_integer(T& var) { var = 0; T sign = 1; int cc = nc();\
    \ for (;\ncc < '0' || '9' < cc; cc = nc()) if (cc == '-') sign = -1; for (; '0'\
    \ <= cc && cc <= '9'; cc =\nnc()) var = (var << 3) + (var << 1) + cc - '0'; var\
    \ = var * sign; var += offset; } int c() {\nchar c; while (c = nc(), c == ' '\
    \ or c == '\\n'); return c; } MyScanner& operator>>(char& var)\n{ var = c(); return\
    \ *this; } MyScanner& operator>>(int& var) { input_integer<int>(var); return\n\
    *this; } MyScanner& operator>>(ll& var) { input_integer<ll>(var); return *this;\
    \ } MyScanner&\noperator>>(string& var) { var = \"\"; int cc = nc(); for (; !isgraph(cc);\
    \ cc = nc()); for\n(; isgraph(cc); cc = nc()) var.push_back(cc); return *this;\
    \ } template <size_t N>\nMyScanner& operator>>(bitset<N>& var) { ll v; input_integer<ll>(v);\
    \ var = bitset<N>(v); return\n*this; } template <typename T> operator T() { T\
    \ x; *this >> x; return x; } template <typename\nT> void operator()(T &t) { *this\
    \ >> t; } template <typename T, typename... Ts> void operator()\n(T &t, Ts &...ts)\
    \ { *this >> t; this->operator()(ts...); } template <typename Iter> void iter\n\
    (Iter first, Iter last) { while (first != last) *this >> *first, first++; } VI\
    \ vi(int n) { VI\nres(n); iter(all(res)); return res; } VVI vvi(int n, int m)\
    \ { VVI res(n); rep(i, n) res[i] =\nvi(m); return res; } VLL vll(int n) { VLL\
    \ res(n); iter(all(res)); return res; } VVLL vvll(int\nn, int m) { VVLL res(n);\
    \ rep(i, n) res[i] = vll(m); return res; } template <typename T> vector\n<T> v(int\
    \ n) { vector<T> res(n); iter(all(res)); return res; } } IN, IN1{-1}; class MyPrinter\n\
    { public: int offset = 0; template <typename T> void output_integer(T var) { var\
    \ += offset; if\n(var == 0) { putchar('0'); return; } if (var < 0) putchar('-'),\
    \ var = -var; char stack[32];\nint stack_p = 0; while (var) stack[stack_p++] =\
    \ '0' + (var % 10), var /= 10; while (stack_p)\nputchar(stack[--stack_p]); } MyPrinter&\
    \ operator<<(char c) { putchar(c); return *this; }\nMyPrinter& operator<<(double\
    \ x) { printf(\"%.10f\", x); return *this; } template <typename T>\nMyPrinter&\
    \ operator<<(T var) { output_integer<T>(var); return *this; } MyPrinter& operator<<(\n\
    char* str_p) { while (*str_p) putchar(*(str_p++)); return *this; } MyPrinter&\
    \ operator<<(const\nchar* str_p) { while (*str_p) putchar(*(str_p++)); return\
    \ *this; } MyPrinter& operator<<(const\nstring& str) { const char* p = str.c_str();\
    \ const char* l = p + str.size(); while (p < l)\nputchar(*p++); return *this;\
    \ } template <typename T> void operator()(T x) { *this << x << newl\n; } template\
    \ <typename T, typename... Ts> void operator()(T x, Ts ...xs) { *this << x <<\
    \ \" \";\nthis->operator()(xs...); } template <typename Iter> void iter(Iter s,\
    \ Iter t) { if (s == t) *\nthis << \"\\n\"; else for (; s != t; s++) *this <<\
    \ *s << \" \\n\"[next(s, 1) == t]; } } OUT, OUT1{1}\n; template <typename T, typename\
    \ U> MyPrinter& operator<<(MyPrinter& out, const pair<T, U>&\nvar) { return out\
    \ << var.first << \" \" << var.second; } template <typename Tuple, size_t I,\n\
    size_t N, enable_if_t<I == N>* = nullptr> MyPrinter& tuple_impl(MyPrinter& out,\
    \ const Tuple&\nvar) { return out; } template <typename Tuple, size_t I, size_t\
    \ N, enable_if_t<I != N>* =\nnullptr> MyPrinter& tuple_impl(MyPrinter& out, const\
    \ Tuple& var) { out << get<I>(var) << \" \";\nreturn tuple_impl<Tuple, I+1, N>(out,\
    \ var); } template <typename... Ts> MyPrinter& operator<<(\nMyPrinter& out, const\
    \ tuple<Ts...>& var) { return tuple_impl<tuple<Ts...>, 0, sizeof...(Ts)>(\nout,\
    \ var); } template <typename T, typename U> MyScanner& operator>>(MyScanner& in,\
    \ pair<T, U>\n& var) { return in >> var.first >> var.second; } template <typename\
    \ Tuple, size_t I, size_t N,\nenable_if_t<I == N>* = nullptr> MyScanner& tuple_impl(MyScanner&\
    \ in, Tuple& var) { return in;\n} template <typename Tuple, size_t I, size_t N,\
    \ enable_if_t<I != N>* = nullptr> MyScanner&\ntuple_impl(MyScanner& in, Tuple&\
    \ var) { in >> get<I>(var); return tuple_impl<Tuple, I+1, N>(in\n, var); } template\
    \ <typename... Ts> MyScanner& operator>>(MyScanner& in, tuple<Ts...>& var) {\n\
    return tuple_impl<tuple<Ts...>, 0, sizeof...(Ts)>(in, var); }\n#pragma GCC diagnostic\
    \ pop\n#line 8 \"verify/aoj/0355.test.cpp\"\n\nint main() {\n  int n = IN;\n \
    \ string u = IN;\n\n  LazyHashSegTree hash(all(u), n);\n\n  rep(IN) {\n    string\
    \ cmd = IN;\n    if (cmd[0] == 's') {\n      int x = IN1, y = IN1; string z =\
    \ IN;\n      hash.modify(x, y+1, z[0]);\n    } else {\n      int a = IN1, b =\
    \ IN1, c = IN1, d = IN1;\n      b++; d++;\n      int eq = 0, neq = min(b-a, d-c)+1;\n\
    \      while (neq - eq > 1) {\n        int m = (eq + neq) / 2;\n        auto l\
    \ = hash.fold(a, a+m);\n        auto r = hash.fold(c, c+m);\n        (l == r ?\
    \ eq : neq) = m;\n      }\n      if (eq == b-a and eq == d-c) OUT(\"e\");\n  \
    \    else if (eq == b-a) OUT(\"s\");\n      else if (eq == d-c) OUT(\"t\");\n\
    \      else {\n        auto s = hash.fold(a+eq, a+eq+1).value;\n        auto t\
    \ = hash.fold(c+eq, c+eq+1).value;\n        OUT(s < t ? \"s\" : \"t\");\n    \
    \  }\n    }\n  }\n}\n"
  code: "#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0355\"\
    \n\n#include \"template.cpp\"\n#include \"string/rolling-hash.cpp\"\n#include\
    \ \"data-structure/lazy-segtree.cpp\"\n#include \"string/hash-monoid.cpp\"\n#include\
    \ \"util/fast-io.cpp\"\n\nint main() {\n  int n = IN;\n  string u = IN;\n\n  LazyHashSegTree\
    \ hash(all(u), n);\n\n  rep(IN) {\n    string cmd = IN;\n    if (cmd[0] == 's')\
    \ {\n      int x = IN1, y = IN1; string z = IN;\n      hash.modify(x, y+1, z[0]);\n\
    \    } else {\n      int a = IN1, b = IN1, c = IN1, d = IN1;\n      b++; d++;\n\
    \      int eq = 0, neq = min(b-a, d-c)+1;\n      while (neq - eq > 1) {\n    \
    \    int m = (eq + neq) / 2;\n        auto l = hash.fold(a, a+m);\n        auto\
    \ r = hash.fold(c, c+m);\n        (l == r ? eq : neq) = m;\n      }\n      if\
    \ (eq == b-a and eq == d-c) OUT(\"e\");\n      else if (eq == b-a) OUT(\"s\");\n\
    \      else if (eq == d-c) OUT(\"t\");\n      else {\n        auto s = hash.fold(a+eq,\
    \ a+eq+1).value;\n        auto t = hash.fold(c+eq, c+eq+1).value;\n        OUT(s\
    \ < t ? \"s\" : \"t\");\n      }\n    }\n  }\n}"
  dependsOn:
  - template.cpp
  - string/rolling-hash.cpp
  - data-structure/lazy-segtree.cpp
  - util/function-objects.cpp
  - string/hash-monoid.cpp
  - data-structure/segtree.cpp
  - util/fast-io.cpp
  isVerificationFile: true
  path: verify/aoj/0355.test.cpp
  requiredBy: []
  timestamp: '2020-05-27 03:32:16+09:00'
  verificationStatus: TEST_ACCEPTED
  verifiedWith: []
documentation_of: verify/aoj/0355.test.cpp
layout: document
redirect_from:
- /verify/verify/aoj/0355.test.cpp
- /verify/verify/aoj/0355.test.cpp.html
title: verify/aoj/0355.test.cpp
---
